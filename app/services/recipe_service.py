# -*- coding: utf-8 -*-
""".ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Aghh6YKtZD_JXfIB92NYVneuqDsD8rcq
"""


import pandas as pd
import os
from dotenv import load_dotenv

from langchain.docstore.document import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_openai import OpenAIEmbeddings
from langchain.vectorstores import FAISS
from langchain.prompts import ChatPromptTemplate
from langchain.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from langchain.chains import RetrievalQAWithSourcesChain

# -----------------------------------------------------
# 1. ë°ì´í„° ë¡œë”© ë° ì „ì²˜ë¦¬ í•¨ìˆ˜
# -----------------------------------------------------
def load_and_process_data(file_path: str) -> list[Document]:
    """CSV íŒŒì¼ì„ ì½ì–´ LangChain Document ê°ì²´ ë¦¬ìŠ¤íŠ¸ë¡œ ë³€í™˜í•©ë‹ˆë‹¤."""
    print(f"'{file_path}'ì—ì„œ ë°ì´í„°ë¥¼ ë¡œë”©í•©ë‹ˆë‹¤...")
    df = pd.read_csv(file_path)

    # ì»¬ëŸ¼ëª… ë³€ê²½
    df = df.rename(columns={
        "RECIPE_NM_KO": "title",
        "SUMRY": "summary",
        "IRDNT_NM": "ingredient_name",
        "IRDNT_CPCTY": "ingredient_amount",
        "COOKING_DC": "instruction"
    })

    documents = []
    for recipe_id, group in df.groupby("RECIPE_ID"):
        # ê·¸ë£¹ì—ì„œ ìœ íš¨í•œ ê°’ ì¶”ì¶œ
        title = group["title"].dropna().iloc[0] if not group["title"].dropna().empty else "ì œëª© ì—†ìŒ"
        summary = group["summary"].dropna().iloc[0] if not group["summary"].dropna().empty else "ìš”ì•½ ì—†ìŒ"

        # ì¬ë£Œ ì •ë³´ í•©ì¹˜ê¸°
        ingredients = group.dropna(subset=["ingredient_name", "ingredient_amount"])
        ingredients_text = ", ".join(
            ingredients.apply(lambda x: f"{x['ingredient_name']} {x['ingredient_amount']}", axis=1)
        )

        # ì¡°ë¦¬ ê³¼ì • ì •ë³´ í•©ì¹˜ê¸° (ìˆœì„œëŒ€ë¡œ ì •ë ¬)
        instructions = group.dropna(subset=["instruction", "COOKING_NO"]).sort_values("COOKING_NO")
        instructions_text = "\n".join(
            instructions.apply(lambda x: f"{int(x['COOKING_NO'])}. {x['instruction']}", axis=1)
        )

        # ìµœì¢… Document ë‚´ìš© êµ¬ì„±
        content = f"""
ìš”ë¦¬ëª…: {title}

ìš”ì•½: {summary}

[ì¬ë£Œ]
{ingredients_text}

[ì¡°ë¦¬ ë°©ë²•]
{instructions_text}
"""
        metadata = {"source": title, "recipe_id": int(recipe_id), "title": title}
        documents.append(Document(page_content=content.strip(), metadata=metadata))

    print(f"âœ… Document ê°ì²´ {len(documents)}ê°œ ìƒì„± ì™„ë£Œ")
    return documents

# -----------------------------------------------------
# 2. ë²¡í„° ë°ì´í„°ë² ì´ìŠ¤ ìƒì„± í•¨ìˆ˜
# -----------------------------------------------------
def create_vector_store(documents: list[Document]):
    """Document ë¦¬ìŠ¤íŠ¸ë¥¼ ë°›ì•„ FAISS ë²¡í„° DBë¥¼ ìƒì„±í•˜ê³  Retrieverë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤."""
    print("í…ìŠ¤íŠ¸ë¥¼ ì²­í¬ë¡œ ë¶„í• í•©ë‹ˆë‹¤...")
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=2000,
        chunk_overlap=200,
        length_function=len
    )
    chunks = text_splitter.split_documents(documents)
    print(f"ì´ {len(chunks)}ê°œì˜ ì²­í¬ë¡œ ë¶„í• ë˜ì—ˆìŠµë‹ˆë‹¤.")

    print("OpenAI ì„ë² ë”©ì„ ì‚¬ìš©í•˜ì—¬ ë²¡í„° DBë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ì‹œê°„ì´ ë‹¤ì†Œ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤...")
    embeddings = OpenAIEmbeddings()

    # FAISS DBë¥¼ ë°°ì¹˜ ë‹¨ìœ„ë¡œ ìƒì„±í•˜ì—¬ ë©”ëª¨ë¦¬ ë° API í˜¸ì¶œ ë¶€ë‹´ ê°ì†Œ
    batch_size = 100
    vec_db = FAISS.from_documents(chunks[:batch_size], embeddings)
    for i in range(batch_size, len(chunks), batch_size):
        batch = chunks[i:i+batch_size]
        vec_db.add_documents(batch)
        print(f"{i + len(batch)}/{len(chunks)} ì²˜ë¦¬ ì™„ë£Œ...")

    print("âœ… ë²¡í„° DB ìƒì„± ì™„ë£Œ!")
    return vec_db.as_retriever()

# -----------------------------------------------------
# 3. ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜
# -----------------------------------------------------
def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜: ì „ì²´ RAG ì²´ì¸ì„ êµ¬ì„±í•˜ê³  ëŒ€í™”í˜•ìœ¼ë¡œ ì‹¤í–‰í•©ë‹ˆë‹¤."""
    # .env íŒŒì¼ì—ì„œ API í‚¤ ë¶ˆëŸ¬ì˜¤ê¸°
    load_dotenv()
    if not os.getenv("OPENAI_API_KEY"):
        print("ğŸš¨ ì˜¤ë¥˜: OPENAI_API_KEYê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. .env íŒŒì¼ì„ í™•ì¸í•˜ì„¸ìš”.")
        return

    # 1ë‹¨ê³„: ë°ì´í„° ì¤€ë¹„
    documents = load_and_process_data("./data/recipes_all.csv")

    # 2ë‹¨ê³„: ë²¡í„° DB ë° Retriever ìƒì„±
    retriever = create_vector_store(documents)

    # --- â–¼â–¼â–¼ ì´ ë¶€ë¶„ì„ ìˆ˜ì •í•©ë‹ˆë‹¤ â–¼â–¼â–¼ ---

    # 3ë‹¨ê³„: LangChain RAG ì²´ì¸ êµ¬ì„± (í•œêµ­ì–´ ë‹µë³€ì„ ìœ„í•œ í”„ë¡¬í”„íŠ¸ ì¶”ê°€)
    llm = ChatOpenAI(model_name='gpt-4o-mini', temperature=0, max_tokens=2000)

    # ëª¨ë¸ì—ê²Œ ì§€ì‹œí•  í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì •ì˜
    prompt_template = """
    ì£¼ì–´ì§„ ë¬¸ì„œë“¤ì„ ë°”íƒ•ìœ¼ë¡œ ë‹¤ìŒ ì§ˆë¬¸ì— ëŒ€í•´ ë‹µë³€í•´ ì£¼ì„¸ìš”.
    ë‹µë³€ì€ ë°˜ë“œì‹œ í•œêµ­ì–´ë¡œ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤.

    **ë¬¸ì„œë“¤:**
    {summaries}

    **ì§ˆë¬¸:**
    {question}

    **ë‹µë³€(ë°˜ë“œì‹œ í•œêµ­ì–´ë¡œ ì‘ì„±):**
    """

    # í”„ë¡¬í”„íŠ¸ ê°ì²´ ìƒì„±
    PROMPT = PromptTemplate(
        template=prompt_template, input_variables=["summaries", "question"]
    )

    # ì²´ì¸ì„ ë§Œë“¤ ë•Œ chain_type_kwargsë¡œ ìš°ë¦¬ê°€ ë§Œë“  í”„ë¡¬í”„íŠ¸ë¥¼ ì „ë‹¬
    chain = RetrievalQAWithSourcesChain.from_chain_type(
        llm=llm,
        retriever=retriever,
        chain_type="stuff",
        return_source_documents=True,
        chain_type_kwargs={"prompt": PROMPT} # ì´ ë¶€ë¶„ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!
    )

    # --- â–²â–²â–² ì—¬ê¸°ê¹Œì§€ ìˆ˜ì •í•©ë‹ˆë‹¤ â–²â–²â–² ---

    print("\n--- ğŸ³ ë¬´ì—‡ì´ë“  ë¬¼ì–´ë³´ì„¸ìš” (ì¢…ë£Œí•˜ë ¤ë©´ 'exit' ì…ë ¥) ---")
    # 4ë‹¨ê³„: ëŒ€í™”í˜• ë£¨í”„ ì‹¤í–‰
    while True:
        query = input("ì§ˆë¬¸: ")
        if query.lower() == 'exit':
            print("í”„ë¡œê·¸ë¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
            break
        if not query.strip():
            continue

        print("\n... ë‹µë³€ì„ ìƒì„± ì¤‘ì…ë‹ˆë‹¤ ...\n")
        result = chain.invoke(query)

        print(f"ë‹µë³€: {result['answer']}")
        if result.get('sources'):
            print(f"ì¶œì²˜: {result['sources']}")
        print("-" * 50)


if __name__ == "__main__":
    main()