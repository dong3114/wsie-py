# -*- coding: utf-8 -*-
""".ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Aghh6YKtZD_JXfIB92NYVneuqDsD8rcq
"""


import pandas as pd
import os
from dotenv import load_dotenv

from langchain.docstore.document import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_openai import OpenAIEmbeddings
from langchain.vectorstores import FAISS
from langchain.prompts import ChatPromptTemplate
from langchain.prompts import PromptTemplate
from langchain_openai import ChatOpenAI
from langchain.chains import RetrievalQAWithSourcesChain

# -----------------------------------------------------
# 1. 데이터 로딩 및 전처리 함수
# -----------------------------------------------------
def load_and_process_data(file_path: str) -> list[Document]:
    """CSV 파일을 읽어 LangChain Document 객체 리스트로 변환합니다."""
    print(f"'{file_path}'에서 데이터를 로딩합니다...")
    df = pd.read_csv(file_path)

    # 컬럼명 변경
    df = df.rename(columns={
        "RECIPE_NM_KO": "title",
        "SUMRY": "summary",
        "IRDNT_NM": "ingredient_name",
        "IRDNT_CPCTY": "ingredient_amount",
        "COOKING_DC": "instruction"
    })

    documents = []
    for recipe_id, group in df.groupby("RECIPE_ID"):
        # 그룹에서 유효한 값 추출
        title = group["title"].dropna().iloc[0] if not group["title"].dropna().empty else "제목 없음"
        summary = group["summary"].dropna().iloc[0] if not group["summary"].dropna().empty else "요약 없음"

        # 재료 정보 합치기
        ingredients = group.dropna(subset=["ingredient_name", "ingredient_amount"])
        ingredients_text = ", ".join(
            ingredients.apply(lambda x: f"{x['ingredient_name']} {x['ingredient_amount']}", axis=1)
        )

        # 조리 과정 정보 합치기 (순서대로 정렬)
        instructions = group.dropna(subset=["instruction", "COOKING_NO"]).sort_values("COOKING_NO")
        instructions_text = "\n".join(
            instructions.apply(lambda x: f"{int(x['COOKING_NO'])}. {x['instruction']}", axis=1)
        )

        # 최종 Document 내용 구성
        content = f"""
요리명: {title}

요약: {summary}

[재료]
{ingredients_text}

[조리 방법]
{instructions_text}
"""
        metadata = {"source": title, "recipe_id": int(recipe_id), "title": title}
        documents.append(Document(page_content=content.strip(), metadata=metadata))

    print(f"✅ Document 객체 {len(documents)}개 생성 완료")
    return documents

# -----------------------------------------------------
# 2. 벡터 데이터베이스 생성 함수
# -----------------------------------------------------
def create_vector_store(documents: list[Document]):
    """Document 리스트를 받아 FAISS 벡터 DB를 생성하고 Retriever를 반환합니다."""
    print("텍스트를 청크로 분할합니다...")
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=2000,
        chunk_overlap=200,
        length_function=len
    )
    chunks = text_splitter.split_documents(documents)
    print(f"총 {len(chunks)}개의 청크로 분할되었습니다.")

    print("OpenAI 임베딩을 사용하여 벡터 DB를 생성합니다. 시간이 다소 걸릴 수 있습니다...")
    embeddings = OpenAIEmbeddings()

    # FAISS DB를 배치 단위로 생성하여 메모리 및 API 호출 부담 감소
    batch_size = 100
    vec_db = FAISS.from_documents(chunks[:batch_size], embeddings)
    for i in range(batch_size, len(chunks), batch_size):
        batch = chunks[i:i+batch_size]
        vec_db.add_documents(batch)
        print(f"{i + len(batch)}/{len(chunks)} 처리 완료...")

    print("✅ 벡터 DB 생성 완료!")
    return vec_db.as_retriever()

# -----------------------------------------------------
# 3. 메인 실행 함수
# -----------------------------------------------------
def main():
    """메인 실행 함수: 전체 RAG 체인을 구성하고 대화형으로 실행합니다."""
    # .env 파일에서 API 키 불러오기
    load_dotenv()
    if not os.getenv("OPENAI_API_KEY"):
        print("🚨 오류: OPENAI_API_KEY가 설정되지 않았습니다. .env 파일을 확인하세요.")
        return

    # 1단계: 데이터 준비
    documents = load_and_process_data("./data/recipes_all.csv")

    # 2단계: 벡터 DB 및 Retriever 생성
    retriever = create_vector_store(documents)

    # --- ▼▼▼ 이 부분을 수정합니다 ▼▼▼ ---

    # 3단계: LangChain RAG 체인 구성 (한국어 답변을 위한 프롬프트 추가)
    llm = ChatOpenAI(model_name='gpt-4o-mini', temperature=0, max_tokens=2000)

    # 모델에게 지시할 프롬프트 템플릿 정의
    prompt_template = """
    주어진 문서들을 바탕으로 다음 질문에 대해 답변해 주세요.
    답변은 반드시 한국어로 작성해야 합니다.

    **문서들:**
    {summaries}

    **질문:**
    {question}

    **답변(반드시 한국어로 작성):**
    """

    # 프롬프트 객체 생성
    PROMPT = PromptTemplate(
        template=prompt_template, input_variables=["summaries", "question"]
    )

    # 체인을 만들 때 chain_type_kwargs로 우리가 만든 프롬프트를 전달
    chain = RetrievalQAWithSourcesChain.from_chain_type(
        llm=llm,
        retriever=retriever,
        chain_type="stuff",
        return_source_documents=True,
        chain_type_kwargs={"prompt": PROMPT} # 이 부분이 추가되었습니다!
    )

    # --- ▲▲▲ 여기까지 수정합니다 ▲▲▲ ---

    print("\n--- 🍳 무엇이든 물어보세요 (종료하려면 'exit' 입력) ---")
    # 4단계: 대화형 루프 실행
    while True:
        query = input("질문: ")
        if query.lower() == 'exit':
            print("프로그램을 종료합니다.")
            break
        if not query.strip():
            continue

        print("\n... 답변을 생성 중입니다 ...\n")
        result = chain.invoke(query)

        print(f"답변: {result['answer']}")
        if result.get('sources'):
            print(f"출처: {result['sources']}")
        print("-" * 50)


if __name__ == "__main__":
    main()